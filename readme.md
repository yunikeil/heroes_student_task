# Отчёт по проекту Heroes

**Реализация алгоритмов генерации армии, симуляции боя, выбора целей и поиска пути**

---

## Введение

В данном проекте реализуется логика для пошаговой стратегии Heroes. Основная цель работы - реализовать несколько алгоритмов, которые используются игровым движком: генерация армии противника, симуляция боя, отбор доступных целей для атаки и поиск кратчайшего пути между юнитами на игровом поле.

Код реализуется отдельно от основного движка игры и подключается в виде JAR-файла.

---

## 1. Генерация армии противника (`GeneratePresetImpl`)

### Описание метода

Метод `generate` формирует армию компьютера на основе списка доступных типов юнитов и ограничения по суммарному количеству очков (`maxPoints`).

При генерации армии соблюдаются следующие условия:

* суммарная стоимость армии не превышает `maxPoints`
* количество юнитов каждого типа не превышает 11
* юниты размещаются на поле размером 3×21 без пересечений

### Используемый алгоритм

Для подбора состава армии используется жадный алгоритм.
Все доступные типы юнитов сортируются по коэффициенту эффективности:

```
эффективность = 0.7 * (атака / стоимость) + 0.3 * (здоровье / стоимость)
```

Далее, пока есть свободные клетки и доступные очки:

* выбирается один из наиболее эффективных юнитов (из первых нескольких в отсортированном списке)
* проверяется ограничение по количеству юнитов данного типа
* юнит добавляется в армию и размещается в случайной свободной клетке

Добавлена небольшая случайность, чтобы армии не были полностью одинаковыми при каждом запуске.

### Обоснование сложности

Пусть:

* `n` - количество типов юнитов (фиксировано и мало)
* `m` - количество юнитов в итоговой армии

Сложность алгоритма:

* сортировка шаблонов: `O(n log n)`
* основной цикл генерации: `O(m)`

Итоговая сложность:

```
O(n log n + m)
```

Что лучше требуемой сложности `O(n · m)`.

---

## 2. Симуляция боя (`SimulateBattleImpl`)

### Описание метода

Метод `simulate` отвечает за полную симуляцию боя между армией игрока и армией компьютера.

Бой происходит по раундам и завершается, когда одна из армий теряет всех живых юнитов.

### Логика симуляции

1. Пока в обеих армиях есть живые юниты:

   * собираются все живые юниты с обеих сторон
   * они сортируются по убыванию значения атаки

2. Юниты по очереди совершают ход:

   * если юнит жив, вызывается `unit.getProgram().attack()`
   * цель выбирается логикой из библиотеки
   * после каждой атаки выводится лог через `PrintBattleLog`

3. Погибшие юниты автоматически исключаются из следующих раундов


### Обоснование сложности

Пусть `n` - количество юнитов в бою.

* сортировка очереди в каждом раунде: `O(n log n)`
* количество раундов в худшем случае - `O(n)`

Итоговая сложность:

```
O(n² log n)
```

Что соответствует требованиям задания.

---

## 3. Отбор целей для атаки (`SuitableForAttackUnitsFinderImpl`)

### Описание метода

Метод `getSuitableUnits` определяет список юнитов, доступных для атаки.

Юнит считается доступным, если он не прикрыт другим юнитом своей армии:

* для левой армии проверяется наличие соседа слева
* для правой армии - наличие соседа справа

Проверка осуществляется по координате `y`.

### Используемый алгоритм

Для каждого ряда:

* собирается множество занятых координат `y`
* каждый юнит проверяется на наличие соседа в соседней клетке
* если сосед отсутствует, юнит добавляется в результат

Если доступных целей нет, метод возвращает пустой список.

### Обоснование сложности

Алгоритм проходит по каждому юниту ровно один раз.

Итоговая сложность:

```
O(n)
```

Где `n` - количество юнитов в армии.

---

## 4. Поиск кратчайшего пути (`UnitTargetPathFinderImpl`)

### Описание метода

Метод `getTargetPath` ищет кратчайший путь между атакующим юнитом и целью на поле размером 27×21.
Другие юниты считаются препятствиями.

Разрешено перемещение:

* по горизонтали
* по вертикали
* по диагонали

### Используемый алгоритм

Для поиска пути используется обход в ширину (BFS):

* игровое поле представлено двумерным массивом
* занятые клетки помечаются как недоступные
* для каждой клетки запоминается родитель
* после нахождения цели путь восстанавливается обратным проходом

Также реализована защита от «срезания углов» при диагональном перемещении через препятствия.

### Обоснование сложности

Пусть:

* `W` - ширина поля
* `H` - высота поля

Каждая клетка посещается не более одного раза.

Итоговая сложность:

```
O(W · H)
```

Что не хуже требуемой сложности `O(W · H · log(W · H))`.

